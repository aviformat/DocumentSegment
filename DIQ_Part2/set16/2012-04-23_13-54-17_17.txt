4d*ancn m £n%meerw? Software 1992. 14. 33-39
ant
Identification of the boundarv surfaces in 3D
finite element codes
Ireneusz Szczygjel, Vndrrej Sttek, Ry«zard ttakcfci 4 Kadrzej J. \o*ak
fnsstiute of Thermo* Tttkmeiofr Sikstm T*€imtm/ Ummrmt Kmm%Iwf M t$t	Htmmt
Foe i given 3D PCM mi duftnetJ * 4ammn comimmfp «vi| • bo—iftmry connectivity arran » ynumd IW latw cwmmi beuwbm mis oto «MH subeeq wm bo*id»ry demeiws *it spwmed An alfpcithni can IN —d wciacl ifet coMMMncy of the input cqmkDvmv may It cm aiic tc mM m n< ponprocwon m Mdn lines r«mo»»j A i»c of ifprnonaie nwcms • idMi
1	INTRODUCTION
Some applications of the finite element method demand integration over the boundary of the body under consideration To carry out this integration tike boundary surface should be defined by grouping the boundary nodes into boundary dements. Heat conduction problems with boundary conditions of the third kind arc a typical example of this class of problem. The standard approach used in structural mechanics of converting boundary loads into nodal forces has no simple equivalence in this case.
The definition of the boundary surface can be also useful in input and output graphic programs where hidden line removal is often required. The knowledge of the bounding surfaces allows an efficient transition from the wireframe model defined by the domain connectivity array into a solid model described by a boundary connectivity array.
The domain connectivity array, grouping the nodes into finite elements, comprises a considerable portion of data needed to run an FEM code and the chance of committing errors when preparing this matrix is high. It is therefore important to check consistency of this array. The developed algorithm performs this task by cross checking, e.g. whether the surfaces generated by processing the connectivity matrix are closed and band the domain
2	DESCRIPTION OF THE ALGORITHM
The present paper is an extension of a previous one dealing with 2D problems.' It consists of three stages:
Advances in Engineering Software 0965-9978/92/S05.00 C 1992 Elsevier Science Publishers Ltd.
(i) uapackmf (Jbe dMM in—uciimj matrix uuo faces ceweectmty nim. WMn tins stage sub-sequent taNt riomo ait convened otto thexr faces. Ha nodes over vM the facts are spanned are stored m a (ace tc—itmiji matnx:
(is) processing the lace im—uinitj matrix to find the boundary dements. The nodes these elements are spanned over are stored m the boundary connectivity antra:
!■»> grouping the boundary elements into dosed boundary surfaces.
The appendix contains the bst of appropriate routines. This computer implementation of the algorithm can deal with linear (I nodes) or quadratic (20 nodes) brick elements as well as with all kinds of transition linear -quadratic ones.
The local nodes numbering pattern of a finite element used in routines listed in the Appendix is shown in Fig. I. The local numbers of nodes within a face are shown in Fig. 2 Other numbering schemes can be easily incorporated into the program.
The first step of the algorithm is executed within the routine UNPACK. All faces bounding a given finite element are generated from data stored in the domain connectivity matrix IX. The scheme of unpacking elements into faces is coded by the local nodes numbering pattern stored in the array IFACEPATTERN, initialized by s DATA statement in the UNPACK routine. The result of the unpacking, i.e. the global numbers of nodes associated with a given face, are stored in the face connectivity matrix I FACE. Each column of this matrix corresponds to one face of a finite element.
Elements having triangular faces are generated by doubling appropriate nodes. An example of this kind of element is shown in Fig. 3 in which the face defined by points 1,2,3,4 in Fig. 1. has been degenerated to line 3-4.
33